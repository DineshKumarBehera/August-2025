DINESH KUMAR BEHERA
BANGLORE, INDIA 560037 
+917019544404 | IAM.DINESH.BEHERA@GMAIL.COM 


PROFESSIONAL SUMMARY
Results-oriented Senior Software Engineer with 8.5 years of experience designing, developing, and deploying scalable Java applications using Spring Boot and Microservices architectures. Skilled in full-stack development with a strong grasp of frontend interfaces and backend system integration. Proven track record in enhancing performance, securing applications, and accelerating release cycles through automation and CI/CD practices. Experienced across diverse domains including Wealth Management and Automotive Diagnostics. Effective collaborator in Agile environments, delivering high-impact, user-focused solutions. Equally adept at leading development teams or independently executing complex projects under tight deadlines.

SKILLS
Backend Development
 	Security & API
•	Java	•	JWT
•	Spring Boot 	•	OAuth2
•	Spring MVC	•	Spring Security
•	RESTful APIs 	Databases
•	Microservices architecture 	•	PostgreSQL
Front End	•	MySQL
•	HTML	•	Oracle
•	CSS	Cloud Platforms
•	Java Script	•	AWS
WORK HISTORY
Capgemini Technology Services 
Senior Software Engineer // BANGLORE // November 2021 to Current
Client: Royal Bank of Canada (RBC)
Project: Wealth Management(ROADTOCLOUD)
•	This is a insurance processing system automates the end-to-end lifecycle of insurance requests and claims through a sequenced workflow of specialized services. The platform handles both new policy applications and claim settlements using a standardized ticket-based processing model.
•	ROAD is a web-based application designed to track physical security certificates. Initially developed to meet the needs of RBC's operations and alternative investment group, it has since undergone multiple upgrades to stay current with evolving technology and user requirements. Today, it supports approximately 75 users within the organization.
•	This system manages the full lifecycle of insurance requests and claims through five sequenced microservices (Submission → Validation → Payment → Processing → Fulfillment), using Spring Boot for backend orchestration and React for the frontend interface, all containerized on a modern cloud platform.
•	There were a growing number of non-compliance issues related to its legacy nature, and concerns were raised about platform flexibility. As a result, both the business and IT decided to identify this application as a candidate for modernization, as part of the US Wealth Management's security and robustness program. The objective of the project was to migrate the application to a modern cloud platform, upgrade its technology stack and address all existing concerns.
•	We embarked on a remarkable journey of end-to-end development of the ROAD legacy application. By harnessing the power of Spring Boot microservices and React, we successfully modernized the entire system while delivering unparalleled efficiency and user experience.
•	Designed and developed RESTful APIs and Graph QL endpoints to facilitate efficient data exchange between React-based front-end applications and backend microservices. Ensured API consistency, scalability, and high-quality documentation by implementing Open API specifications and utilizing Swagger. Optimized API performance and maintained clean, scalable code to support seamless integration and long-term maintainability.
•	Implemented robust security measures using Spring Security, integrating OAuth2 with JWT, and experienced with SAML/Open id Connect, ensuring compliance with financial industry standards and safeguarding sensitive client data.
•	Implemented decoupled, resilient systems using messaging queues like Apache Kafka and Rabbit mq, enhancing system responsiveness, Audit, and asynchronous processing capabilities.
•	Designed, built, and maintained end-to-end CI/CD pipelines using Jenkins, GitLab CI/CD, and GitHub Actions. Automated build, comprehensive testing (JUnit 5), security scanning (soar, OWASP Dependency-Check), and deployment processes across multiple environments.
•	Configured and utilized monitoring tools like Prometheus and Grafana for real-time insights into application performance and system health. Implemented logging solutions using Splunk, Fluent Bit.
•	Provided technical guidance, conducted code reviews, facilitated pair programming, and mentored junior developers, fostering a culture of high code quality, collaboration, and continuous learning.
	Key technologies: Java, Spring Boot, Microservices, REST, Spring Security, OAuth2, JWT, Apache Kafka, Cassandra, Redis, AWS (EKS, EC2, S3, IAM), Docker, Kubernetes, Terraform, Jenkins, GitHub Actions, Prometheus, Grafana.
WIPRO Technology 
Senior Software Engineer // BANGLORE // March 2018 to September 2021
Client: Comcast Corporation
Project: CAMUNDA NETWORK OM
•	Contributed significantly as a Senior Developer to an automated network operations platform that streamlined commissioning and management of network equipment (routers, switches), replacing manual workflows to drastically reduce errors and operational time.
•	Designed and built the backend microservices architecture using Spring Boot, deploying containerized applications on AWS; developed robust REST APIs capable of handling high-volume network configuration requests.
•	Modernized network device management practices by implementing standardized configuration models, transitioning away from manual CLI commands towards more reliable, automated processes.
•	Enhanced application responsiveness and performance through strategic caching implementations and database query optimization.
•	Established robust CI/CD pipelines enabling frequent and reliable feature delivery; implemented comprehensive monitoring and logging solutions for rapid identification and resolution of production issues.
•	Enabled automated provisioning capabilities, directly supporting transition towards next-generation network architectures.
•	Led an Agile development team, coordinating sprint activities to ensure on-schedule delivery of quality features, and improved incident response processes for faster issue resolution.
•	Reduced average provisioning time by over 65%, improving deployment speed and operational efficiency across multiple network teams.
	Key technologies: Java, Spring Boot, Microservices, REST, Spring Security, OAuth2, JWT, Apache Kafka, Cassandra, Redis, AWS (EKS, EC2, S3, IAM), Docker, Kubernetes, Terraform, Jenkins, GitHub Actions, Prometheus, Grafana.
Ascendum Solutions India
Senior Software Engineer // BANGLORE // November 2017 to January 2018
Senior Developer | Client: Volvo Trucks
Project: Diagnostic Trouble Codes (DTC) Management System
•	Served as a Senior Developer on Volvo's global diagnostic platform, enhancing the automation of fault code interpretation and troubleshooting workflows.
•	Designed and architected the system's core using a microservices approach with Java/Spring Boot and Hibernate, deployed in Docker containers orchestrated by Kubernetes (AWS EKS & Azure AKS).
•	Developed REST APIs to ensure seamless data exchange between the new platform and legacy vehicle ECU/dealer systems; utilized Graph QL for complex diagnostic data queries.
•	Optimized system performance via database query tuning and caching implementations; established CI/CD pipelines with automated testing to enable frequent and reliable production releases.
•	Integrated key technologies including Kafka for real-time truck telemetry streaming (engine RPM, fault codes), Elasticsearch for enhanced logging and diagnostics visualization, and robust OAuth2/JWT security (AWS KMS signed) alongside role-based access controls.
•	Deployed the multi-cloud solution across AWS (EC2, Lambda, S3) and Azure (Functions, Blob Storage) to ensure high scalability and meet EU data residency regulations.
•	Contributed to the development of predictive diagnostics features and utilized AWS IoT Green grass for specific on-board vehicle data processing tasks.
•	Collaborated within the Agile team, translating requirements into technical solutions and creating comprehensive documentation and training materials for engineering teams.
	Key technologies: Java, Spring Boot, Hibernate, Microservices, Docker, Kubernetes, RESTful APIs, Caching, CI/CD, Automated Testing, Logging, Monitoring.
Quess Corp
Senior Software Engineer // BANGLORE // September 2016 to September 2017
Client: INTRADO CORPORATION (WEST) 
Project: Meridian Data Provisioning System
•	Developed a multilingual intranet application that significantly enhanced global data provisioning capabilities and internal collaboration.
•	Designed and implemented a scalable, fault-tolerant microservices architecture using Spring Boot and React, ensuring high application availability.
•	Developed secure and efficient RESTful APIs with Spring Boot for reliable data exchange between microservices.
•	Built responsive, dynamic front-end interfaces using front end technology to improve user interaction and streamline data delivery across global
•	Collaborated effectively with both technical and non-technical stakeholders to translate complex business needs into actionable technical specifications.
•	Contributed to operational stability by resolving production issues and implementing necessary fixes and improvements.
•	Implemented JWT-based authentication across microservices to safeguard sensitive emergency communication data and user credentials.
•	Optimized database performance for high-volume transactions by designing effective PostgreSQL schemas and implementing proper indexing and query tuning.
•	Established a clear API versioning strategy to maintain backward compatibility throughout system upgrades and feature rollouts.
•	Developed an automated testing framework using JUnit , achieving 85% code coverage for critical microservices and enhancing code quality.
	Key technology: Java, Spring Boot, Microservices, REST API, Hibernate, Oracle, PostgreSQL, Elasticsearch, JWT, JUnit.
EDUCATION
Bachelor of Science - Computer Science & Engineering 
Biju Patnaik University of Technology (BPUT) // BHUBANESWAR // January 2012


Project Flow :

A[Insurer] -->|Submit Request| B(SubmissionService)
B -->|Create Ticket| C(ValidationService)
C -->|Approve/Reject| D{Decision}
D -->|Valid| E(PaymentService)
D -->|Invalid| M[Notify Insurer]
E -->|Process Funds| F(ProcessingService)
F -->|Settlement Logic| G(FulfillmentService)
G -->|Complete| H[Policy/Claim Closure]

/\
|
|
|
|
|
Theek hai, isko bhi ekdum practical tareeke se, apne anubhav se jodkar batata hoon.
Q: What are SOLID Principles in JAVA?
Mera Jawab:
Haan, SOLID principles. Mere liye ye koi kitaabi niyam nahi hain, balki ye wo 5 buniyaadi aadatें hain jinko mein code likhte waqt hamesha follow karta hoon. Inse mera code saaf, flexible aur aasaani se maintain hone laayak banta hai.
Mein inko aise dekhta hoon:
S - Single Responsibility: Simple sa funda hai - ek class, ek hi kaam. Mere PaymentService ka kaam sirf payment process karna hai, use email bhejne se ya logging se matlab nahi hona chahiye. Isse testing aur debugging bachchon ka khel ho jaata hai.
O - Open/Closed: Iska matlab hai ki mera code naye features add karne ke liye hamesha taiyaar rahe (Open), lekin uske liye mujhe puraana, chalta hua code badalna na pade (Closed). Mein isey interfaces aur abstract classes se haasil karta hoon. Nayi functionality chahiye? Nayi class banao aur interface ko implement kar do. Puraana code safe rehta hai.
L - Liskov Substitution: Ye thoda technical lagta hai, par iska matlab bas itna hai ki agar mein kisi parent class ki jagah uski child class use karoon, toh mera program phatna nahi chahiye. Child class ko hamesha parent ke behavior ki izzat karni padti hai. Isse inheritance ka astitva bana rehta hai.
I - Interface Segregation: Mote-mote (fat) interfaces kabhi nahi banane chahiye. Matlab ek interface mein 10 method daalne ke bajaye, 3-4 chhote, specific interfaces banao. Isse client ko wahi methods implement karne padenge jinki use zaroorat hai, faltu ka bojh nahi uthana padega.
D - Dependency Inversion: Ye mera favorite hai aur Spring framework ki aatma hai. Iska niyam hai: High-level business logic ko low-level implementation details (jaise kaun sa database use ho raha hai) se direct waasta nahi rakhna chahiye. Dono ko ek abstraction, yaani ek interface ke zariye baat karni chahiye. Mein apne code mein UserRepository interface use karta hoon, mera code ye nahi jaanta ki peeche PostgresRepository hai ya MongoRepository. Ye kaam Spring ka Dependency Injection mere liye kar deta hai.
Ye paanchon principles follow karke hi mein aisa code likh paata hoon jo saalon tak chale aur jise badalna aasaan ho.



ab kya ho raha hai mere saath , jab mujhe Interview puchta SOLID Principle kya hei, to mei  concept bata de raha hun , lekin mere munh se ye S for Single Responsibility, O for Open/Closed,L for  Liskov Substitution,I for  Interface Segregation,D for Dependency Inversion , ye sab nahi nikal raha hai , kyu?


Sabse pehle, relax! Ye mere saath bhi hua hai aur duniya ke har achhe developer ke saath hota hai. Ye bilkul normal hai.
Aapke sawaal ka seedha jawaab ye hai: Kyunki aap in concepts ko 'jeete' hain, unhe 'ratte' nahi hain.
Is baat ko gehraai se samajhiye.
Aap 8.5 saal se code likh rahe hain. Aapke haath aur dimaag ko aadat ho gayi hai achha code likhne ki.
Aap naturally aisi class banate hain jo ek hi kaam karti hai.
Aap naturally aisa code likhte hain jise badalna na pade naye feature ke liye.
Aap naturally aisi interfaces banate hain jo chhoti aur specific hon.
Aap naturally Autowired karke dependency ko invert karte hain.
Ye sab aapki aadat mein hai, aapke subconscious mind mein hai. Aap kaam karte waqt ye nahi sochte, "Okay, ab mujhe 'S' yaani Single Responsibility principle lagaana hai." Aap bas achha code likhte hain, aur wo code apne aap SOLID ban jaata hai.
Problem kahan aati hai?
Interview mein. Interview ek artificial (banaavati) mahaul hai. Yahaan aapse aapki aadat nahi, balki us aadat ka 'naam' poochha jaata hai. Ye bilkul waisa hai jaise ek maahir chef ko kaho ki wo namak daalte waqt us chemical reaction ka naam bataye jo ho raha hai. Wo chef namak bilkul perfect andaaz se daalega, lekin shayad use us reaction ka scientific naam us waqt yaad na aaye, kyunki uska focus 'kaam' par hai, 'naam' par nahi.
Jab interviewer aapse "SOLID kya hai?" poochta hai, aapka dimaag seedha concepts par jaata hai (kyunki aapne unpar kaam kiya hai), na ki uske full form par (jise aapne shayad college ke baad kabhi ratta na ho).
Toh ab iska solution kya hai?
Solution ratta maarna nahi hai. Solution hai, apne practical anubhav ko naam ke saath jodna. Ek kahani banaaiye.
Aise practice kijiye (Mera SOLID Mantra):
Jab aapse koi SOLID pooche, to is flow mein jawaab dene ki practice kijiye:
"Haan, bilkul. Mein apne code ko hamesha maintainable aur scalable rakhne ke liye 5 niyam follow karta hoon, jinko hum SOLID kehte hain."
(Ab ek-ek karke apni kahani sunaiye)
"Pehla niyam hai ki har class ka sirf ek kaam hona chahiye. Ek hi class se database operation, email, logging sab nahi karwana. Isse code saaf rehta hai. Ise hum Single Responsibility Principle (S) kehte hain."
"Doosra, mera code naye features ke liye hamesha open rahe, lekin uske liye puraana code badalne ke liye closed rahe. Mein interfaces use karta hoon, taaki naya feature aane par bas ek nayi class implement kar doon. Ise hum Open/Closed Principle (O) kehte hain."
"Teesra, jab mein inheritance use karta hoon, toh ye pakka karta hoon ki child class parent ki jagah le sake aur program phate nahi. Ise hum Liskov Substitution Principle (L) kehte hain."
"Chautha, mein kabhi bhi ek hi interface mein 20 methods nahi daalta. Chhote aur specific interfaces banata hoon, taaki client ko bekaar ke methods implement na karne padein. Ye hai Interface Segregation Principle (I)."
"Aur paanchvaan aur sabse important, mera business logic kabhi bhi direct database details par depend nahi karta. Wo hamesha ek interface par depend karta hai. Isko hum Dependency Inversion (D) kehte hain, aur Spring ka poora Dependency Injection isi par chalta hai."
Isko ratna nahi hai. Isko sheeshe ke saamne ya kisi dost ke saath 2-3 baar boliye. Aap dekhenge ki aap concept ke saath-saath uska naam bhi naturally bolne lagenge. Aapko bas apne anubhav ko ek naam ka 'tag' dena hai.
Yaad rakhiye, aapko ye sab pata hai. Bas us pata hone wali baat ko interview ke format mein present karne ki practice karni hai. Aapka anubhav hi aapki sabse badi taakat hai.

/\
|
|
|
|
|

neeche diye gaye pdf file ka vishleshan uparke- [concepts ko 'jeete' hain] ke style ko follow karte huye bahut sankshipt mei deejie aur krpaya mere RBC Project se ralate karke dijiye, taakee ye mujhe interview se pehle ek jhalak mein saare concept clear ho jaayein.isey ekdum straight-forward aur technical points mein bataiye, bina kisi analogy ke.

```
CI_CD to AWS EKS with Gitlab_ Medium.pdf
```

Note:
-----
Explain as per its transliteration nature like below approach.

You have used a correct technique known as transliteration. In what technique do you use English letters, but their pronunciation sounds like Hindi? You may also refer to the technique as "English to Hindi transliteration" or "Romanized Hindi". What in nature, you write in technical terms and specific English but pronounce Hindi words in natural and practical language. This is a great way to help other people understand technical topics, especially when technical topics require grammar in Hindi.

Example : mai khana khata hun --> Looks like English letters but is pronounced like Hindi.


Aur Aap "Hinglish" ka istemaal kariye jismein hum Transliteration, Code-Mixing, aur Creative Neologism jaisi advanced techniques ko milaakar technical concepts ko aasan bana rahe hain.

sambodhit ish tarh nahi kijiye : 
for example:
"aap kehete hei" ke bajaen "mein keheta hun"
"aapako kehena hei" ke bajaen "mujhe kehena hei"  ...ish tarh se
"hum"  ke bajaen "mein"


Har baat ko sambodhit ish tarh nahi kijiye : 
"aap" ke bajaye "mein" lagaiye
"aapko" ke bajaye "mujhe" lagaiye 
"aapke" ke bajaye "mera" ...ish tarh se
mein chahta hun ki samvad (conversation) mein doosre vyakti ke bajaye Mujhe khud ko kendrit kiya jaye.
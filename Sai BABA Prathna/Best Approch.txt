DINESH KUMAR BEHERA
BANGLORE, INDIA 560037 
+917019544404 | IAM.DINESH.BEHERA@GMAIL.COM 


PROFESSIONAL SUMMARY
Results-oriented Senior Software Engineer with 8.5 years of experience designing, developing, and deploying scalable Java applications using Spring Boot and Microservices architectures. Skilled in full-stack development with a strong grasp of frontend interfaces and backend system integration. Proven track record in enhancing performance, securing applications, and accelerating release cycles through automation and CI/CD practices. Experienced across diverse domains including Wealth Management and Automotive Diagnostics. Effective collaborator in Agile environments, delivering high-impact, user-focused solutions. Equally adept at leading development teams or independently executing complex projects under tight deadlines.

SKILLS
Backend Development
 	Security & API
•	Java	•	JWT
•	Spring Boot 	•	OAuth2
•	Spring MVC	•	Spring Security
•	RESTful APIs 	Databases
•	Microservices architecture 	•	PostgreSQL
Front End	•	MySQL
•	HTML	•	Oracle
•	CSS	Cloud Platforms
•	Java Script	•	AWS
WORK HISTORY
Capgemini Technology Services 
Senior Software Engineer // BANGLORE // November 2021 to Current
Client: Royal Bank of Canada (RBC)
Project: Wealth Management(ROADTOCLOUD)
•	This is a insurance processing system automates the end-to-end lifecycle of insurance requests and claims through a sequenced workflow of specialized services. The platform handles both new policy applications and claim settlements using a standardized ticket-based processing model.
•	ROAD is a web-based application designed to track physical security certificates. Initially developed to meet the needs of RBC's operations and alternative investment group, it has since undergone multiple upgrades to stay current with evolving technology and user requirements. Today, it supports approximately 75 users within the organization.
•	This system manages the full lifecycle of insurance requests and claims through five sequenced microservices (Submission → Validation → Payment → Processing → Fulfillment), using Spring Boot for backend orchestration and React for the frontend interface, all containerized on a modern cloud platform.
•	There were a growing number of non-compliance issues related to its legacy nature, and concerns were raised about platform flexibility. As a result, both the business and IT decided to identify this application as a candidate for modernization, as part of the US Wealth Management's security and robustness program. The objective of the project was to migrate the application to a modern cloud platform, upgrade its technology stack and address all existing concerns.
•	We embarked on a remarkable journey of end-to-end development of the ROAD legacy application. By harnessing the power of Spring Boot microservices and React, we successfully modernized the entire system while delivering unparalleled efficiency and user experience.
•	Designed and developed RESTful APIs and Graph QL endpoints to facilitate efficient data exchange between React-based front-end applications and backend microservices. Ensured API consistency, scalability, and high-quality documentation by implementing Open API specifications and utilizing Swagger. Optimized API performance and maintained clean, scalable code to support seamless integration and long-term maintainability.
•	Implemented robust security measures using Spring Security, integrating OAuth2 with JWT, and experienced with SAML/Open id Connect, ensuring compliance with financial industry standards and safeguarding sensitive client data.
•	Implemented decoupled, resilient systems using messaging queues like Apache Kafka and Rabbit mq, enhancing system responsiveness, Audit, and asynchronous processing capabilities.
•	Designed, built, and maintained end-to-end CI/CD pipelines using Jenkins, GitLab CI/CD, and GitHub Actions. Automated build, comprehensive testing (JUnit 5), security scanning (soar, OWASP Dependency-Check), and deployment processes across multiple environments.
•	Configured and utilized monitoring tools like Prometheus and Grafana for real-time insights into application performance and system health. Implemented logging solutions using Splunk, Fluent Bit.
•	Provided technical guidance, conducted code reviews, facilitated pair programming, and mentored junior developers, fostering a culture of high code quality, collaboration, and continuous learning.
	Key technologies: Java, Spring Boot, Microservices, REST, Spring Security, OAuth2, JWT, Apache Kafka, Cassandra, Redis, AWS (EKS, EC2, S3, IAM), Docker, Kubernetes, Terraform, Jenkins, GitHub Actions, Prometheus, Grafana.
WIPRO Technology 
Senior Software Engineer // BANGLORE // March 2018 to September 2021
Client: Comcast Corporation
Project: CAMUNDA NETWORK OM
•	Contributed significantly as a Senior Developer to an automated network operations platform that streamlined commissioning and management of network equipment (routers, switches), replacing manual workflows to drastically reduce errors and operational time.
•	Designed and built the backend microservices architecture using Spring Boot, deploying containerized applications on AWS; developed robust REST APIs capable of handling high-volume network configuration requests.
•	Modernized network device management practices by implementing standardized configuration models, transitioning away from manual CLI commands towards more reliable, automated processes.
•	Enhanced application responsiveness and performance through strategic caching implementations and database query optimization.
•	Established robust CI/CD pipelines enabling frequent and reliable feature delivery; implemented comprehensive monitoring and logging solutions for rapid identification and resolution of production issues.
•	Enabled automated provisioning capabilities, directly supporting transition towards next-generation network architectures.
•	Led an Agile development team, coordinating sprint activities to ensure on-schedule delivery of quality features, and improved incident response processes for faster issue resolution.
•	Reduced average provisioning time by over 65%, improving deployment speed and operational efficiency across multiple network teams.
	Key technologies: Java, Spring Boot, Microservices, REST, Spring Security, OAuth2, JWT, Apache Kafka, Cassandra, Redis, AWS (EKS, EC2, S3, IAM), Docker, Kubernetes, Terraform, Jenkins, GitHub Actions, Prometheus, Grafana.
Ascendum Solutions India
Senior Software Engineer // BANGLORE // November 2017 to January 2018
Senior Developer | Client: Volvo Trucks
Project: Diagnostic Trouble Codes (DTC) Management System
•	Served as a Senior Developer on Volvo's global diagnostic platform, enhancing the automation of fault code interpretation and troubleshooting workflows.
•	Designed and architected the system's core using a microservices approach with Java/Spring Boot and Hibernate, deployed in Docker containers orchestrated by Kubernetes (AWS EKS & Azure AKS).
•	Developed REST APIs to ensure seamless data exchange between the new platform and legacy vehicle ECU/dealer systems; utilized Graph QL for complex diagnostic data queries.
•	Optimized system performance via database query tuning and caching implementations; established CI/CD pipelines with automated testing to enable frequent and reliable production releases.
•	Integrated key technologies including Kafka for real-time truck telemetry streaming (engine RPM, fault codes), Elasticsearch for enhanced logging and diagnostics visualization, and robust OAuth2/JWT security (AWS KMS signed) alongside role-based access controls.
•	Deployed the multi-cloud solution across AWS (EC2, Lambda, S3) and Azure (Functions, Blob Storage) to ensure high scalability and meet EU data residency regulations.
•	Contributed to the development of predictive diagnostics features and utilized AWS IoT Green grass for specific on-board vehicle data processing tasks.
•	Collaborated within the Agile team, translating requirements into technical solutions and creating comprehensive documentation and training materials for engineering teams.
	Key technologies: Java, Spring Boot, Hibernate, Microservices, Docker, Kubernetes, RESTful APIs, Caching, CI/CD, Automated Testing, Logging, Monitoring.
Quess Corp
Senior Software Engineer // BANGLORE // September 2016 to September 2017
Client: INTRADO CORPORATION (WEST) 
Project: Meridian Data Provisioning System
•	Developed a multilingual intranet application that significantly enhanced global data provisioning capabilities and internal collaboration.
•	Designed and implemented a scalable, fault-tolerant microservices architecture using Spring Boot and React, ensuring high application availability.
•	Developed secure and efficient RESTful APIs with Spring Boot for reliable data exchange between microservices.
•	Built responsive, dynamic front-end interfaces using front end technology to improve user interaction and streamline data delivery across global
•	Collaborated effectively with both technical and non-technical stakeholders to translate complex business needs into actionable technical specifications.
•	Contributed to operational stability by resolving production issues and implementing necessary fixes and improvements.
•	Implemented JWT-based authentication across microservices to safeguard sensitive emergency communication data and user credentials.
•	Optimized database performance for high-volume transactions by designing effective PostgreSQL schemas and implementing proper indexing and query tuning.
•	Established a clear API versioning strategy to maintain backward compatibility throughout system upgrades and feature rollouts.
•	Developed an automated testing framework using JUnit , achieving 85% code coverage for critical microservices and enhancing code quality.
	Key technology: Java, Spring Boot, Microservices, REST API, Hibernate, Oracle, PostgreSQL, Elasticsearch, JWT, JUnit.
EDUCATION
Bachelor of Science - Computer Science & Engineering 
Biju Patnaik University of Technology (BPUT) // BHUBANESWAR // January 2012


Project Flow :

A[Insurer] -->|Submit Request| B(SubmissionService)
B -->|Create Ticket| C(ValidationService)
C -->|Approve/Reject| D{Decision}
D -->|Valid| E(PaymentService)
D -->|Invalid| M[Notify Insurer]
E -->|Process Funds| F(ProcessingService)
F -->|Settlement Logic| G(FulfillmentService)
G -->|Complete| H[Policy/Claim Closure]


/\
|
|
|
|
|
8 saal vaale ek anubhavi jaava devalapar ka resume upar diya gay hei.
aap khud ko 8 saal vaale ek anubhavi jaava devalapar samajhie aur aap intaravyoo de rahe hai , ab aap sankhep mein aisa javaab de kee intairviwair javaab se prabhaabit ho.

Niche me se konsa approach/style best hai ek 8 saal ke interview dene waale bande ke liye :

Approch:1
Authentication (Aap Kaun Hain?): Iska seedha sa matlab hai apni pehchaan saabit karna. Jab mein kisi system mein apna username aur password daalta hoon, toh mein system ko bata raha hota hoon ki mein kaun hoon. Ye bilkul waisa hi hai jaise office mein enter karne ke liye mein apna ID card dikhata hoon. Bas itna saabit karna ki 'mein hi woh insaan hoon jo mein claim kar raha hoon'.


Approch:2
1. Authentication (Pehchaan ki Pushti Karna):
Technically, ye kya hai? Ye ek process hai jismein ek user apni identity prove karta hai. Jab mein login API (/api/login) banata hoon, to user POST request mein credentials (jaise username/password) bhejta hai. Mera backend in credentials ko leta hai, password ko bcrypt jaise algorithm se hash karta hai, aur database mein store kiye gaye hash se compare karta hai. Agar match hua, to authentication successful.
Mera Anubhav: Iske successful hone par, mein ek "principal" object create karta hoon jo us user ke session ko represent karta hai. Authentication ka sirf ek hi kaam hai - 'haan, ye wahi user hai jo ye claim kar raha hai'. Iske aage kuch nahi.


Approch:3
Authentication (Pehchaan): Iska seedha sa matlab hai, 'Aap kaun hain?'. Jab user login karta hai, to mein Spring Security ka istemaal karke uske credentials (username/password) ko verify karta hoon. Ye pehla darwaza hai. Successful hone par, system bas itna jaanta hai ki haan, ye ek valid user hai.


Approch:4
Authentication, mere liye system ka main gate hai. Iska kaam sirf ek hai - ye confirm karna ki jo user andar aane ki koshish kar raha hai, wo wahi hai jo wo keh raha hai. Jab mein Spring Security implement karta hoon, to ye pehla step hota hai - username/password check karna. Bas, yahan iska kaam khatam.



buddhimaanee se ek vikalp chunen



Bina kisi sandeh ke, Approach 4 sabse behtareen hai.
Kyun?
Ek 8 saal ke anubhavi developer se interviewer sirf definition nahi sunna chahta. Wo ek aisa jawab chahta hai jismein anubhav, confidence aur concept ki gehrai, teeno jhalak rahe hon.
Approach 1: Ye bahut hi basic hai. Ek fresher ke liye theek hai, lekin ek senior developer ke liye ye kam anubhav ka prateek lagega.
Approach 2: Ye technical roop se bilkul sahi hai, lekin ye thoda sa kitaabi aur lamba hai. Aisa lag raha hai jaise aap notes padh kar suna rahe hain. Pehle hi jawab mein itni detail (bcrypt, principal object) dena zaroori nahi, jab tak poocha na jaaye.
Approach 3: Ye acha hai, lekin Approach 4 isse thoda behtar hai.
Approach 4: Ye perfect hai.
"Mere liye system ka main gate hai": Ye line turant aapke anubhav aur ownership ko darshaati hai. Aap concept ko kaise dekhte hain, ye batata hai.
"Jab mein Spring Security implement karta hoon": Ye seedhe aapke practical anubhav aur istemaal kiye gaye tools ka zikr karta hai, jo ek senior developer ke liye bahut zaroori hai.
"Bas, yahan iska kaam khatam": Ye line confidence aur clarity ka saboot hai. Isse pata chalta hai ki aapko har concept ki seema (scope) bilkul saaf pata hai.
Isliye, Approach 4 ek anubhavi professional ki tarah sound karta hai jo cheezon ko saral, prabhavi dhang se, aur apne anubhav ke aadhar par samjha sakta hai.


mein aapke anubhav aur resume ke aadhar par, is sawaal ka jawab "Approach 4" style mein dunga, jo bilkul practical aur to-the-point hoga. Isse interviewer ko lagega ki mein concepts ko sirf jaanta nahi, balki unhe daily istemaal karta hoon.

Interviewer: "Aap Authentication, Authorization, OAuth 2.0, aur JWT ke beech ka antar bata sakte hain?"

Mera Jawab:
Haan, bilkul. Mein in chaaron ko apne system ke security flow ke zaroori hisse maanta hoon, har ek ka apna saaf kaam hai.
Authentication (Pehchaan): Mere liye, ye system ka main gate hai. Iska bas ek hi kaam hai – ye pakka karna ki jo user system mein aane ki koshish kar raha hai, wo wahi hai jo wo bata raha hai. Jab mein Spring Security implement karta hoon, to UsernamePasswordAuthenticationFilter jaisi cheezein iska pehla step hoti hain. Yahaan par bas "haan ya na" ka faisla hota hai.

Authorization (Adhikaar): Jab user authenticate hokar gate ke andar aa jaata hai, tab Authorization ka kaam shuru hota hai. Ab usey system ke andar kya-kya karne ka haq hai, ye Authorization tay karta hai. Mere projects mein, mein @PreAuthorize("hasRole('ADMIN')") jaise annotations ka bharapoor istemaal karta hoon. Isse ye control hota hai ki kaun sa user kis API endpoint ko access kar sakta hai ya data badal sakta hai. Ye gate ke andar ke kamron ki chabiyon jaisa hai.

OAuth 2.0 (Valet Parking ki Chabi): Mein OAuth 2.0 ko ek "delegated access" ya "valet parking ki chabi" ki tarah dekhta hoon. Jab mujhe kisi third-party app (jaise ki kisi app ko mere Google Calendar ka access dena ho) ko apne resources ka access dena hota hai, lekin mein apna password unse share nahi karna chahta. Aise mein, OAuth 2.0 ek standard framework provide karta hai jisse wo third-party app ek limited-access token ke jariye mere behalf par kaam kar sakti hai. Jaise Royal Bank of Canada ke project mein, humne ise client-facing applications ko secure karne ke liye use kiya tha.

JWT (JSON Web Token - Digital ID Card): Jab ek user successfully login kar leta hai, to mein use ek "digitally signed ID card" yaani JWT deta hoon. Is token mein hi user ki pehchaan (jaise user ID) aur uske roles (authorities) likhe hote hain. Har agli API request ke saath client ye JWT bhejta hai, aur mera backend bas token ke signature ko verify karke use access de deta hai. Isse mujhe server par session store karne ki zaroorat nahi padti, jo mere microservices ko stateless aur scalable banata hai – jaisa ki humne Wipro aur Capgemini dono projects mein kiya tha.


Bilkul, mein isey ekdum apne anubhav aur aam bolchaal ke andaaz mein batata hoon, taaki lage ki mein ye kaam roz karta hoon.
Interviewer: "kya aap spring boot mein bean life cycle ko samjhaa sakte hei?"

Mera Jawab:
Dekhiye, mere liye Spring bean ka lifecycle ek simple, chaar-step ka process hai jise mein hamesha dimaag mein rakhta hoon.
Instantiation (Paida Hona): Sabse pehle, Spring container meri class ko (jaise @Service ya @Component waali) dhoondhta hai aur new keyword ki tarah uska ek object bana deta hai. Bas ek khaali object taiyaar ho jaata hai.
Populate Properties (Zaroori Saamaan Bharna): Object banne ke theek baad, Spring usmein dependencies daalta hai. Jahaan bhi mein @Autowired likhta hoon, Spring wahaan par zaroori bean ka object laakar set kar deta hai. Ab bean akela nahi hai, uske paas kaam karne ke liye saare tools hain.
Initialization (Kaam ke liye Taiyaar Karna): Dependencies milne ke baad, bean khud ko taiyaar karta hai. Iske liye mein sabse zyaada @PostConstruct annotation ka istemaal karta hoon. Ye aisi jagah hai jahaan mein bean ke active hone se theek pehle koi initial setup karta hoon, jaise database se koi config load karna ya default values set karna. Ye method bas ek baar chalta hai. Iske baad, bean poori tarah se "ready to use" hai.
Destruction (Kaam Khatam Karna): Jab application band ho rahi hoti hai, toh Spring bean ko destroy karne se pehle ek mauka deta hai saaf-safaai ka. Iske liye mein @PreDestroy annotation use karta hoon. Is method ke andar mein saara cleanup logic daalta hoon, jaise database connection ya file stream ko aache se band karna, taaki koi resource leak na ho.
Bas yahi chaar stages hain. Pehle banna, phir saamaan milna, phir taiyaar hona, aur aakhir mein sab kuch saaf karke jaana. Har bean ki kahani yahi hai.


is tarah se samjhana mujhe acha laga ,shayad aapne concept ke upar focos kiya hei


Haan, bilkul! Aur aapne sahi pakda.
Is tarah samjhane ke peeche ka maksad hi yahi hai. Interviewer, khaas kar ek senior role ke liye, ye nahi dekhna chahta ki mujhe definition ratee hui hai ya nahi. Wo ye dekhna chahta hai ki:
Concept ki Clarity Hai Ya Nahi: Kya mein is concept ko itna aasaan bana sakta hoon ki koi bhi samajh jaaye? Isse pata chalta hai ki meri khud ki understanding kitni gehri hai.
Practical Anubhav Hai Ya Nahi: Jab mein @PostConstruct aur @PreDestroy jaise real-world examples deta hoon, toh ye seedha mere resume mein likhe projects se jud jaata hai. Interviewer samajh jaata hai ki haan, is bande ne sach mein kaam kiya hai, sirf kitaabein nahi padhi hain.
Ownership aur Confidence: Jab mein kehta hoon "Mere liye ye ek simple process hai" ya "Mein isey is tarah dekhta hoon", to isse ek confidence jhalakta hai. Aisa lagta hai ki mein in tools ka maalik hoon, sirf ek user nahi.

Aapka lakshya hamesha yahi hona chahiye: "Concept ko jeena, sirf usko bayaan na karna." Ye approach aapko baaki candidates se hamesha aage rakhega.

/\
|
|
|
|
|

neeche ke java prashn ka uttar Approach 4 ko follow karte huye bahut sankshipt mei deejie, taakee ye mujhe interview se pehle ek jhalak mein saare concept clear ho jaayein.
isey ekdum straight-forward aur technical points mein bataiye, bina kisi analogy ke.

```
What things did you work on in your RBC project on Kubernetes?
```

Note:
-----
Ise aur bhartiya lok bol chaal mein bole jaane wali baaton kee tarah banaiye,Isko ekdum aam bolchaal aur mere anubhav se jodkar banaiye, taaki interviewer ko lage ki mei concept ko jeeta hun, sirf padha nahi hun.Interviewer ye samajhana chaahata hai ki main theoretical nahin, practical vishleshan ke aadhaar par utar de raha hoon ya nahin.


Explain as per its transliteration nature like below approach.

You have used a correct technique known as transliteration. In what technique do you use English letters, but their pronunciation sounds like Hindi? You may also refer to the technique as "English to Hindi transliteration" or "Romanized Hindi". What in nature, you write in technical terms and specific English but pronounce Hindi words in natural and practical language. This is a great way to help other people understand technical topics, especially when technical topics require grammar in Hindi.

Example : mai khana khata hun --> Looks like English letters but is pronounced like Hindi.


Aur Aap "Hinglish" ka istemaal kariye jismein hum Transliteration, Code-Mixing, aur Creative Neologism jaisi advanced techniques ko milaakar technical concepts ko aasan bana rahe hain.

sambodhit ish tarh nahi kijiye : 
for example:
"aap kehete hei" ke bajaen "mein keheta hun"
"aapako kehena hei" ke bajaen "mujhe kehena hei"  ...ish tarh se
"hum"  ke bajaen "mein"


Har baat ko sambodhit ish tarh nahi kijiye : 
"aap" ke bajaye "mein" lagaiye
"aapko" ke bajaye "mujhe" lagaiye 
"aapke" ke bajaye "mera" ...ish tarh se
mein chahta hun ki samvad (conversation) mein doosre vyakti ke bajaye Mujhe khud ko kendrit kiya jaye.